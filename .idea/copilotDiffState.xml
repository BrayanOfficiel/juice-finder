<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/api/restaurants/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/restaurants/route.ts" />
              <option name="originalContent" value="/**&#10; * API Route: /api/restaurants&#10; * GET: Récupère les restaurants depuis la base MySQL&#10; */&#10;&#10;import { NextRequest, NextResponse } from 'next/server';&#10;import { prisma } from '@/lib/db';&#10;import type { Restaurant as PrismaRestaurant } from '@prisma/client';&#10;&#10;export async function GET(request: NextRequest) {&#10;  try {&#10;    const searchParams = request.nextUrl.searchParams;&#10;    &#10;    // Paramètres de recherche&#10;    const search = searchParams.get('search') || '';&#10;    const type = searchParams.get('type') || '';&#10;    const region = searchParams.get('region') || '';&#10;    const department = searchParams.get('department') || '';&#10;    const limit = parseInt(searchParams.get('limit') || '20');&#10;    const offset = parseInt(searchParams.get('offset') || '0');&#10;    const sortBy = searchParams.get('sortBy') || 'none';&#10;    const userLat = parseFloat(searchParams.get('userLat') || '0');&#10;    const userLon = parseFloat(searchParams.get('userLon') || '0');&#10;    &#10;    // Construction de la requête WHERE&#10;    const where: {&#10;      name?: { contains: string } | { not: null };&#10;      type?: string;&#10;      region?: string;&#10;      department?: string;&#10;    } = {};&#10;    &#10;    // TOUJOURS exclure les restaurants sans nom&#10;    where.name = search &#10;      ? { contains: search }&#10;      : { not: null };&#10;    &#10;    // Filtre par type&#10;    if (type) {&#10;      where.type = type;&#10;    }&#10;    &#10;    // Filtre par région&#10;    if (region) {&#10;      where.region = region;&#10;    }&#10;    &#10;    // Filtre par département (égalité exacte pour MySQL)&#10;    if (department) {&#10;      where.department = department;&#10;    }&#10;    &#10;    // Récupération des données avec pagination&#10;    let restaurants: PrismaRestaurant[];&#10;    let totalCount: number;&#10;&#10;    // Si tri par distance, utiliser une requête SQL brute avec formule Haversine&#10;    if (sortBy === 'distance' &amp;&amp; userLat !== 0 &amp;&amp; userLon !== 0) {&#10;      // Construction de la clause WHERE pour SQL brut&#10;      let whereClause = 'WHERE name IS NOT NULL';&#10;      const queryParams: any[] = [];&#10;      &#10;      if (search) {&#10;        whereClause += ' AND name LIKE ?';&#10;        queryParams.push(`%${search}%`);&#10;      }&#10;      if (type) {&#10;        whereClause += ' AND type = ?';&#10;        queryParams.push(type);&#10;      }&#10;      if (region) {&#10;        whereClause += ' AND region = ?';&#10;        queryParams.push(region);&#10;      }&#10;      if (department) {&#10;        whereClause += ' AND department = ?';&#10;        queryParams.push(department);&#10;      }&#10;      &#10;      // Calcul de la distance avec la formule Haversine (version simplifiée)&#10;      // Distance en km = 111.045 * sqrt((lat2-lat1)^2 + (cos(lat1)*(lon2-lon1))^2)&#10;      const distanceFormula = `&#10;        (111.045 * SQRT(&#10;          POW(lat - ${userLat}, 2) + &#10;          POW(COS(RADIANS(${userLat})) * (lon - ${userLon}), 2)&#10;        ))&#10;      `;&#10;      &#10;      // Requête avec distance calculée&#10;      const query = `&#10;        SELECT *, ${distanceFormula} as distance&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;        ORDER BY distance ASC&#10;        LIMIT ${limit} OFFSET ${offset}&#10;      `;&#10;      &#10;      const countQuery = `&#10;        SELECT COUNT(*) as count&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;      `;&#10;      &#10;      try {&#10;        const [restaurantsResult, countResult]: any = await Promise.all([&#10;          prisma.$queryRawUnsafe(query, ...queryParams),&#10;          prisma.$queryRawUnsafe(countQuery, ...queryParams),&#10;        ]);&#10;&#10;        restaurants = restaurantsResult;&#10;        totalCount = Number(countResult[0]?.count) || 0;&#10;      } catch (error) {&#10;        console.error('Erreur requête SQL distance:', error);&#10;        throw error;&#10;      }&#10;    } else {&#10;      // Tri par nom (ordre alphabétique)&#10;      const orderBy = sortBy === 'name' ? { name: 'asc' as const } : { name: 'asc' as const };&#10;      &#10;      [restaurants, totalCount] = await Promise.all([&#10;        prisma.restaurant.findMany({&#10;          where,&#10;          take: limit,&#10;          skip: offset,&#10;          orderBy,&#10;        }),&#10;        prisma.restaurant.count({ where }),&#10;      ]);&#10;    }&#10;    &#10;    // Transformation des données pour correspondre au format attendu&#10;    const results = restaurants.map((r: PrismaRestaurant) =&gt; ({&#10;      id: r.id.toString(),&#10;      name: r.name,&#10;      type: r.type,&#10;      cuisine: r.cuisine,&#10;      phone: r.phone,&#10;      website: r.website,&#10;      email: r.email,&#10;      street: r.street,&#10;      housenumber: r.housenumber,&#10;      postcode: r.postcode,&#10;      city: r.city,&#10;      region: r.region,&#10;      department: r.department,&#10;      opening_hours: r.opening_hours,&#10;      wheelchair: r.wheelchair,&#10;      delivery: r.delivery,&#10;      takeaway: r.takeaway,&#10;      outdoor_seating: r.outdoor_seating,&#10;      meta_geo_point: r.lat &amp;&amp; r.lon ? { lat: r.lat, lon: r.lon } : undefined,&#10;      osm_id: r.osm_id,&#10;      osm_type: r.osm_type,&#10;    }));&#10;    &#10;    return NextResponse.json({&#10;      total_count: totalCount,&#10;      results,&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Erreur API /api/restaurants:', error);&#10;    return NextResponse.json(&#10;      { error: 'Erreur lors de la récupération des restaurants' },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * API Route: /api/restaurants&#10; * GET: Récupère les restaurants depuis la base MySQL&#10; */&#10;&#10;import { NextRequest, NextResponse } from 'next/server';&#10;import { prisma } from '@/lib/db';&#10;import type { Restaurant as PrismaRestaurant } from '@prisma/client';&#10;&#10;export async function GET(request: NextRequest) {&#10;  try {&#10;    const searchParams = request.nextUrl.searchParams;&#10;    &#10;    // Paramètres de recherche&#10;    const search = searchParams.get('search') || '';&#10;    const type = searchParams.get('type') || '';&#10;    const region = searchParams.get('region') || '';&#10;    const department = searchParams.get('department') || '';&#10;    const limit = parseInt(searchParams.get('limit') || '20');&#10;    const offset = parseInt(searchParams.get('offset') || '0');&#10;    const sortBy = searchParams.get('sortBy') || 'none';&#10;    const userLat = parseFloat(searchParams.get('userLat') || '0');&#10;    const userLon = parseFloat(searchParams.get('userLon') || '0');&#10;    &#10;    // Construction de la requête WHERE&#10;    const where: {&#10;      name?: { contains: string } | { not: null };&#10;      type?: string;&#10;      region?: string;&#10;      department?: string;&#10;    } = {};&#10;    &#10;    // TOUJOURS exclure les restaurants sans nom&#10;    where.name = search &#10;      ? { contains: search }&#10;      : { not: null };&#10;    &#10;    // Filtre par type&#10;    if (type) {&#10;      where.type = type;&#10;    }&#10;    &#10;    // Filtre par région&#10;    if (region) {&#10;      where.region = region;&#10;    }&#10;    &#10;    // Filtre par département (égalité exacte pour MySQL)&#10;    if (department) {&#10;      where.department = department;&#10;    }&#10;    &#10;    // Récupération des données avec pagination&#10;    let restaurants: PrismaRestaurant[];&#10;    let totalCount: number;&#10;&#10;    // Si tri par distance, utiliser une requête SQL brute avec formule Haversine&#10;    if (sortBy === 'distance' &amp;&amp; userLat !== 0 &amp;&amp; userLon !== 0) {&#10;      // Construction de la clause WHERE pour SQL brut&#10;      let whereClause = 'WHERE name IS NOT NULL';&#10;      const queryParams: string[] = [];&#10;      &#10;      if (search) {&#10;        whereClause += ' AND name LIKE ?';&#10;        queryParams.push(`%${search}%`);&#10;      }&#10;      if (type) {&#10;        whereClause += ' AND type = ?';&#10;        queryParams.push(type);&#10;      }&#10;      if (region) {&#10;        whereClause += ' AND region = ?';&#10;        queryParams.push(region);&#10;      }&#10;      if (department) {&#10;        whereClause += ' AND department = ?';&#10;        queryParams.push(department);&#10;      }&#10;      &#10;      // Calcul de la distance avec la formule Haversine (version simplifiée)&#10;      // Distance en km = 111.045 * sqrt((lat2-lat1)^2 + (cos(lat1)*(lon2-lon1))^2)&#10;      const distanceFormula = `&#10;        (111.045 * SQRT(&#10;          POW(lat - ${userLat}, 2) + &#10;          POW(COS(RADIANS(${userLat})) * (lon - ${userLon}), 2)&#10;        ))&#10;      `;&#10;      &#10;      // Requête avec distance calculée&#10;      const query = `&#10;        SELECT *, ${distanceFormula} as distance&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;        ORDER BY distance ASC&#10;        LIMIT ${limit} OFFSET ${offset}&#10;      `;&#10;      &#10;      const countQuery = `&#10;        SELECT COUNT(*) as count&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;      `;&#10;      &#10;      try {&#10;        // Mise à jour des types pour les résultats des requêtes SQL brutes&#10;        const [restaurantsResult, countResult] = await Promise.all([&#10;          prisma.$queryRawUnsafe&lt;Array&lt;{ [key: string]: unknown }&gt;&gt;(query, ...queryParams),&#10;          prisma.$queryRawUnsafe&lt;Array&lt;{ count: number }&gt;&gt;(countQuery, ...queryParams),&#10;        ]);&#10;&#10;        // Conversion explicite des résultats pour correspondre au type attendu&#10;        restaurants = restaurantsResult.map((r) =&gt; ({&#10;          id: r.id as number,&#10;          name: r.name as string | null,&#10;          type: r.type as string | null,&#10;          phone: r.phone as string | null,&#10;          website: r.website as string | null,&#10;          email: r.email as string | null,&#10;          cuisine: r.cuisine as string | null,&#10;          street: r.street as string | null,&#10;          housenumber: r.housenumber as string | null,&#10;          postcode: r.postcode as string | null,&#10;          city: r.city as string | null,&#10;          region: r.region as string | null,&#10;          department: r.department as string | null,&#10;          opening_hours: r.opening_hours as string | null,&#10;          wheelchair: r.wheelchair as string | null,&#10;          delivery: r.delivery as string | null,&#10;          takeaway: r.takeaway as string | null,&#10;          outdoor_seating: r.outdoor_seating as string | null,&#10;          lat: r.lat as number | null,&#10;          lon: r.lon as number | null,&#10;          osm_id: r.osm_id as string | null,&#10;          osm_type: r.osm_type as string | null,&#10;          meta_osm_id: r.meta_osm_id as string | null,&#10;          meta_osm_type: r.meta_osm_type as string | null,&#10;          last_update: r.last_update as Date | null,&#10;          created_at: r.created_at as Date || new Date(), // Correction pour éviter null&#10;        }));&#10;&#10;        totalCount = Number(countResult[0]?.count) || 0;&#10;      } catch (error) {&#10;        console.error('Erreur requête SQL distance:', error);&#10;        throw error;&#10;      }&#10;    } else {&#10;      // Tri par nom (ordre alphabétique)&#10;      const orderBy = sortBy === 'name' ? { name: 'asc' as const } : { name: 'asc' as const };&#10;      &#10;      [restaurants, totalCount] = await Promise.all([&#10;        prisma.restaurant.findMany({&#10;          where,&#10;          take: limit,&#10;          skip: offset,&#10;          orderBy,&#10;        }),&#10;        prisma.restaurant.count({ where }),&#10;      ]);&#10;    }&#10;    &#10;    // Transformation des données pour correspondre au format attendu&#10;    const results = restaurants.map((r: PrismaRestaurant) =&gt; ({&#10;      id: r.id.toString(),&#10;      name: r.name,&#10;      type: r.type,&#10;      cuisine: r.cuisine,&#10;      phone: r.phone,&#10;      website: r.website,&#10;      email: r.email,&#10;      street: r.street,&#10;      housenumber: r.housenumber,&#10;      postcode: r.postcode,&#10;      city: r.city,&#10;      region: r.region,&#10;      department: r.department,&#10;      opening_hours: r.opening_hours,&#10;      wheelchair: r.wheelchair,&#10;      delivery: r.delivery,&#10;      takeaway: r.takeaway,&#10;      outdoor_seating: r.outdoor_seating,&#10;      meta_geo_point: r.lat &amp;&amp; r.lon ? { lat: r.lat, lon: r.lon } : undefined,&#10;      osm_id: r.osm_id,&#10;      osm_type: r.osm_type,&#10;    }));&#10;    &#10;    return NextResponse.json({&#10;      total_count: totalCount,&#10;      results,&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Erreur API /api/restaurants:', error);&#10;    return NextResponse.json(&#10;      { error: 'Erreur lors de la récupération des restaurants' },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>