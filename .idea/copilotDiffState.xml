<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/api/arrondissements/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/arrondissements/route.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="/**&#10; * API Route: /api/arrondissements&#10; * GET: Récupère la liste des arrondissements depuis la colonne city&#10; * Format: &quot;Paris 1er Arrondissement&quot;, &quot;Lyon 3e Arrondissement&quot;, etc.&#10; */&#10;&#10;import {NextResponse} from 'next/server';&#10;import {prisma} from '@/lib/db';&#10;&#10;export async function GET() {&#10;    try {&#10;        // Récupération des villes distinctes&#10;        const cities = await prisma.restaurant.findMany({&#10;            where: {&#10;                city: {&#10;                    not: null,&#10;                },&#10;            },&#10;            select: {&#10;                city: true,&#10;            },&#10;            distinct: ['city'],&#10;        });&#10;&#10;        // Filtrer uniquement les arrondissements (contiennent &quot;Arrondissement&quot;)&#10;        type CityRow = { city: string | null };&#10;        &#10;        const arrondissements = (cities as CityRow[])&#10;            .filter((c): c is { city: string } =&gt; &#10;                !!c.city &amp;&amp; &#10;                c.city.trim() !== &quot;&quot; &amp;&amp;&#10;                /\d+e?r?\s+Arrondissement$/i.test(c.city)&#10;            )&#10;            .map(c =&gt; c.city.trim())&#10;            .sort((a, b) =&gt; {&#10;                // Extraire la ville et le numéro pour un tri correct&#10;                const matchA = a.match(/^(.+?)\s+(\d+)e?r?\s+Arrondissement$/i);&#10;                const matchB = b.match(/^(.+?)\s+(\d+)e?r?\s+Arrondissement$/i);&#10;                &#10;                if (matchA &amp;&amp; matchB) {&#10;                    const [, cityA, numA] = matchA;&#10;                    const [, cityB, numB] = matchB;&#10;                    &#10;                    // D'abord trier par ville&#10;                    if (cityA !== cityB) {&#10;                        return cityA.localeCompare(cityB);&#10;                    }&#10;                    // Puis par numéro d'arrondissement&#10;                    return parseInt(numA) - parseInt(numB);&#10;                }&#10;                &#10;                return a.localeCompare(b);&#10;            });&#10;&#10;        return NextResponse.json({&#10;            arrondissements,&#10;            count: arrondissements.length,&#10;        });&#10;&#10;    } catch (error) {&#10;        console.error('Erreur API /api/arrondissements:', error);&#10;        return NextResponse.json(&#10;            {error: 'Erreur lors de la récupération des arrondissements'},&#10;            {status: 500}&#10;        );&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/cities/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/cities/route.ts" />
              <option name="updatedContent" value="/**&#10; * API Route: /api/cities&#10; * GET: Récupère la liste unique des villes depuis la base MySQL&#10; */&#10;&#10;import {NextResponse} from 'next/server';&#10;import {prisma} from '@/lib/db';&#10;&#10;export async function GET() {&#10;    try {&#10;        // Récupération des villes distinctes, triées&#10;        const cities = await prisma.restaurant.findMany({&#10;            where: {&#10;                city: {&#10;                    not: null,&#10;                },&#10;            },&#10;            select: {&#10;                city: true,&#10;            },&#10;            distinct: ['city'],&#10;            orderBy: {&#10;                city: 'asc',&#10;            },&#10;        });&#10;&#10;        // Extraction et nettoyage&#10;        type CityRow = { city: string | null };&#10;&#10;        const cityList = (cities as CityRow[])&#10;            .map((c) =&gt; c.city)&#10;            .filter((c: string | null): c is string =&gt; !!c &amp;&amp; c.trim() !== &quot;&quot;)&#10;            .sort();&#10;&#10;        return NextResponse.json({&#10;            cities: cityList,&#10;            count: cityList.length,&#10;        });&#10;&#10;    } catch (error) {&#10;        console.error('Erreur API /api/cities:', error);&#10;        return NextResponse.json(&#10;            {error: 'Erreur lors de la récupération des villes'},&#10;            {status: 500}&#10;        );&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/departments/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/departments/route.ts" />
              <option name="updatedContent" value="/**&#10; * API Route: /api/departments&#10; * GET: Récupère la liste unique des départements depuis la base MySQL&#10; */&#10;&#10;import {NextResponse} from 'next/server';&#10;import {prisma} from '@/lib/db';&#10;&#10;export async function GET() {&#10;    try {&#10;        // Récupération des départements distincts, triés&#10;        const departments = await prisma.restaurant.findMany({&#10;            where: {&#10;                department: {&#10;                    not: null,&#10;                },&#10;            },&#10;            select: {&#10;                department: true,&#10;            },&#10;            distinct: ['department'],&#10;            orderBy: {&#10;                department: 'asc',&#10;            },&#10;        });&#10;&#10;        // Extraction et nettoyage&#10;        type DepartmentRow = { department: string | null };&#10;&#10;        const departmentList = (departments as DepartmentRow[])&#10;            .map((d) =&gt; d.department)&#10;            .filter((d: string | null): d is string =&gt; !!d &amp;&amp; d.trim() !== &quot;&quot;)&#10;            .sort();&#10;&#10;        return NextResponse.json({&#10;            departments: departmentList,&#10;            count: departmentList.length,&#10;        });&#10;&#10;    } catch (error) {&#10;        console.error('Erreur API /api/departments:', error);&#10;        return NextResponse.json(&#10;            {error: 'Erreur lors de la récupération des départements'},&#10;            {status: 500}&#10;        );&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/locations/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/locations/route.ts" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="/**&#10; * API Route: /api/locations&#10; * GET: Récupère la liste combinée des villes (sans arrondissements) et départements&#10; */&#10;&#10;import {NextResponse} from 'next/server';&#10;import {prisma} from '@/lib/db';&#10;&#10;export async function GET() {&#10;    try {&#10;        // Récupération des villes et départements en parallèle&#10;        const [cities, departments] = await Promise.all([&#10;            prisma.restaurant.findMany({&#10;                where: {&#10;                    city: {&#10;                        not: null,&#10;                    },&#10;                },&#10;                select: {&#10;                    city: true,&#10;                },&#10;                distinct: ['city'],&#10;            }),&#10;            prisma.restaurant.findMany({&#10;                where: {&#10;                    department: {&#10;                        not: null,&#10;                    },&#10;                },&#10;                select: {&#10;                    department: true,&#10;                },&#10;                distinct: ['department'],&#10;            }),&#10;        ]);&#10;&#10;        // Extraction et nettoyage&#10;        type CityRow = { city: string | null };&#10;        type DepartmentRow = { department: string | null };&#10;&#10;        // Filtrer les villes en EXCLUANT les arrondissements&#10;        const cityList = (cities as CityRow[])&#10;            .map((c) =&gt; c.city)&#10;            .filter((c: string | null): c is string =&gt; &#10;                !!c &amp;&amp; &#10;                c.trim() !== &quot;&quot; &amp;&amp;&#10;                // Exclure les arrondissements (contiennent &quot;Xe Arrondissement&quot;)&#10;                !/\d+e?r?\s+Arrondissement$/i.test(c)&#10;            )&#10;            .map(c =&gt; {&#10;                // Pour les villes principales (Paris, Lyon, Marseille), on garde juste le nom&#10;                // sans &quot;Arrondissement&quot; au cas où&#10;                return c.trim();&#10;            });&#10;        &#10;        const departmentList = (departments as DepartmentRow[])&#10;            .map((d) =&gt; d.department)&#10;            .filter((d: string | null): d is string =&gt; !!d &amp;&amp; d.trim() !== &quot;&quot;);&#10;&#10;        // Fusionner et dédupliquer&#10;        const combinedSet = new Set([...cityList, ...departmentList]);&#10;        const locationList = Array.from(combinedSet).sort();&#10;&#10;        return NextResponse.json({&#10;            locations: locationList,&#10;            count: locationList.length,&#10;        });&#10;&#10;    } catch (error) {&#10;        console.error('Erreur API /api/locations:', error);&#10;        return NextResponse.json(&#10;            {error: 'Erreur lors de la récupération des localisations'},&#10;            {status: 500}&#10;        );&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/restaurants/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/restaurants/route.ts" />
              <option name="originalContent" value="/**&#10; * API Route: /api/restaurants&#10; * GET: Récupère les restaurants depuis la base MySQL&#10; */&#10;&#10;import { NextRequest, NextResponse } from 'next/server';&#10;import { prisma } from '@/lib/db';&#10;&#10;type RestaurantRow = {&#10;  id: number | string;&#10;  name: string | null;&#10;  type: string | null;&#10;  cuisine: string | null;&#10;  phone: string | null;&#10;  website: string | null;&#10;  email: string | null;&#10;  street: string | null;&#10;  housenumber: string | null;&#10;  postcode: string | null;&#10;  city: string | null;&#10;  region: string | null;&#10;  department: string | null;&#10;  opening_hours: string | null;&#10;  wheelchair: string | null;&#10;  delivery: string | null;&#10;  takeaway: string | null;&#10;  outdoor_seating: string | null;&#10;  lat: number | null;&#10;  lon: number | null;&#10;  osm_id: string | null;&#10;  osm_type: string | null;&#10;};&#10;&#10;export async function GET(request: NextRequest) {&#10;  try {&#10;    const searchParams = request.nextUrl.searchParams;&#10;    &#10;    // Paramètres de recherche&#10;    const search = searchParams.get('search') || '';&#10;    const type = searchParams.get('type') || '';&#10;    const region = searchParams.get('region') || '';&#10;    const department = searchParams.get('department') || '';&#10;    const limit = parseInt(searchParams.get('limit') || '20');&#10;    const offset = parseInt(searchParams.get('offset') || '0');&#10;    const sortBy = searchParams.get('sortBy') || 'none';&#10;    const userLat = parseFloat(searchParams.get('userLat') || '0');&#10;    const userLon = parseFloat(searchParams.get('userLon') || '0');&#10;    &#10;    // Construction de la requête WHERE&#10;    const where: {&#10;      name?: { contains: string } | { not: null };&#10;      type?: string;&#10;      region?: string;&#10;      department?: string;&#10;    } = {};&#10;    &#10;    // TOUJOURS exclure les restaurants sans nom&#10;    where.name = search &#10;      ? { contains: search }&#10;      : { not: null };&#10;    &#10;    // Filtre par type&#10;    if (type) {&#10;      where.type = type;&#10;    }&#10;    &#10;    // Filtre par région&#10;    if (region) {&#10;      where.region = region;&#10;    }&#10;    &#10;    // Filtre par département (égalité exacte pour MySQL)&#10;    if (department) {&#10;      where.department = department;&#10;    }&#10;    &#10;    // Récupération des données avec pagination&#10;    let restaurants: RestaurantRow[];&#10;    let totalCount: number;&#10;&#10;    // Si tri par distance, utiliser une requête SQL brute avec formule Haversine&#10;    if (sortBy === 'distance' &amp;&amp; userLat !== 0 &amp;&amp; userLon !== 0) {&#10;      // Construction de la clause WHERE pour SQL brut&#10;      let whereClause = 'WHERE name IS NOT NULL';&#10;      const queryParams: any[] = [];&#10;      &#10;      if (search) {&#10;        whereClause += ' AND name LIKE ?';&#10;        queryParams.push(`%${search}%`);&#10;      }&#10;      if (type) {&#10;        whereClause += ' AND type = ?';&#10;        queryParams.push(type);&#10;      }&#10;      if (region) {&#10;        whereClause += ' AND region = ?';&#10;        queryParams.push(region);&#10;      }&#10;      if (department) {&#10;        whereClause += ' AND department = ?';&#10;        queryParams.push(department);&#10;      }&#10;      &#10;      // Calcul de la distance avec la formule Haversine (version simplifiée)&#10;      // Distance en km = 111.045 * sqrt((lat2-lat1)^2 + (cos(lat1)*(lon2-lon1))^2)&#10;      const distanceFormula = `&#10;        (111.045 * SQRT(&#10;          POW(lat - ${userLat}, 2) + &#10;          POW(COS(RADIANS(${userLat})) * (lon - ${userLon}), 2)&#10;        ))&#10;      `;&#10;      &#10;      // Requête avec distance calculée&#10;      const query = `&#10;        SELECT *, ${distanceFormula} as distance&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;        ORDER BY distance ASC&#10;        LIMIT ${limit} OFFSET ${offset}&#10;      `;&#10;      &#10;      const countQuery = `&#10;        SELECT COUNT(*) as count&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;      `;&#10;      &#10;      try {&#10;        const [restaurantsResult, countResult]: any = await Promise.all([&#10;          prisma.$queryRawUnsafe(query, ...queryParams),&#10;          prisma.$queryRawUnsafe(countQuery, ...queryParams),&#10;        ]);&#10;&#10;        restaurants = restaurantsResult;&#10;        totalCount = Number(countResult[0]?.count) || 0;&#10;      } catch (error) {&#10;        console.error('Erreur requête SQL distance:', error);&#10;        throw error;&#10;      }&#10;    } else {&#10;      // Tri par nom (ordre alphabétique)&#10;      const orderBy = sortBy === 'name' ? { name: 'asc' as const } : { name: 'asc' as const };&#10;      &#10;      [restaurants, totalCount] = await Promise.all([&#10;        prisma.restaurant.findMany({&#10;          where,&#10;          take: limit,&#10;          skip: offset,&#10;          orderBy,&#10;        }),&#10;        prisma.restaurant.count({ where }),&#10;      ]);&#10;    }&#10;    &#10;    // Transformation des données pour correspondre au format attendu&#10;    const results = restaurants.map((r: RestaurantRow) =&gt; ({&#10;      id: r.id.toString(),&#10;      name: r.name,&#10;      type: r.type,&#10;      cuisine: r.cuisine,&#10;      phone: r.phone,&#10;      website: r.website,&#10;      email: r.email,&#10;      street: r.street,&#10;      housenumber: r.housenumber,&#10;      postcode: r.postcode,&#10;      city: r.city,&#10;      region: r.region,&#10;      department: r.department,&#10;      opening_hours: r.opening_hours,&#10;      wheelchair: r.wheelchair,&#10;      delivery: r.delivery,&#10;      takeaway: r.takeaway,&#10;      outdoor_seating: r.outdoor_seating,&#10;      meta_geo_point: r.lat &amp;&amp; r.lon ? { lat: r.lat, lon: r.lon } : undefined,&#10;      osm_id: r.osm_id,&#10;      osm_type: r.osm_type,&#10;    }));&#10;    &#10;    return NextResponse.json({&#10;      total_count: totalCount,&#10;      results,&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Erreur API /api/restaurants:', error);&#10;    return NextResponse.json(&#10;      { error: 'Erreur lors de la récupération des restaurants' },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * API Route: /api/restaurants&#10; * GET: Récupère les restaurants depuis la base MySQL&#10; */&#10;&#10;import { NextRequest, NextResponse } from 'next/server';&#10;import { prisma } from '@/lib/db';&#10;&#10;type RestaurantRow = {&#10;  id: number | string;&#10;  name: string | null;&#10;  type: string | null;&#10;  cuisine: string | null;&#10;  phone: string | null;&#10;  website: string | null;&#10;  email: string | null;&#10;  street: string | null;&#10;  housenumber: string | null;&#10;  postcode: string | null;&#10;  city: string | null;&#10;  region: string | null;&#10;  department: string | null;&#10;  opening_hours: string | null;&#10;  wheelchair: string | null;&#10;  delivery: string | null;&#10;  takeaway: string | null;&#10;  outdoor_seating: string | null;&#10;  lat: number | null;&#10;  lon: number | null;&#10;  osm_id: string | null;&#10;  osm_type: string | null;&#10;};&#10;&#10;export async function GET(request: NextRequest) {&#10;  try {&#10;    const searchParams = request.nextUrl.searchParams;&#10;    &#10;    // Paramètres de recherche&#10;    const search = searchParams.get('search') || '';&#10;    const type = searchParams.get('type') || '';&#10;    const location = searchParams.get('location') || '';&#10;    const arrondissement = searchParams.get('arrondissement') || '';&#10;    const limit = parseInt(searchParams.get('limit') || '20');&#10;    const offset = parseInt(searchParams.get('offset') || '0');&#10;    const sortBy = searchParams.get('sortBy') || 'none';&#10;    const userLat = parseFloat(searchParams.get('userLat') || '0');&#10;    const userLon = parseFloat(searchParams.get('userLon') || '0');&#10;    &#10;    // Construction de la requête WHERE&#10;    const where: Record&lt;string, unknown&gt; = {};&#10;    &#10;    // TOUJOURS exclure les restaurants sans nom&#10;    where.name = search &#10;      ? { contains: search }&#10;      : { not: null };&#10;    &#10;    // Filtre par type&#10;    if (type) {&#10;      where.type = type;&#10;    }&#10;    &#10;    // Filtre par localisation (ville OU département)&#10;    if (location) {&#10;      where.OR = [&#10;        { city: location },&#10;        { department: location }&#10;      ];&#10;    }&#10;    &#10;    // Filtre par arrondissement (maintenant c'est un nom de ville complet: &quot;Paris 1er Arrondissement&quot;)&#10;    if (arrondissement) {&#10;      where.city = arrondissement;&#10;    }&#10;    &#10;    // Récupération des données avec pagination&#10;    let restaurants: RestaurantRow[];&#10;    let totalCount: number;&#10;&#10;    // Si tri par distance, utiliser une requête SQL brute avec formule Haversine&#10;    if (sortBy === 'distance' &amp;&amp; userLat !== 0 &amp;&amp; userLon !== 0) {&#10;      // Construction de la clause WHERE pour SQL brut&#10;      let whereClause = 'WHERE name IS NOT NULL';&#10;      const queryParams: (string | number)[] = [];&#10;      &#10;      if (search) {&#10;        whereClause += ' AND name LIKE ?';&#10;        queryParams.push(`%${search}%`);&#10;      }&#10;      if (type) {&#10;        whereClause += ' AND type = ?';&#10;        queryParams.push(type);&#10;      }&#10;      if (location) {&#10;        whereClause += ' AND (city = ? OR department = ?)';&#10;        queryParams.push(location, location);&#10;      }&#10;      if (arrondissement) {&#10;        whereClause += ' AND city = ?';&#10;        queryParams.push(arrondissement);&#10;      }&#10;      &#10;      // Calcul de la distance avec la formule Haversine (version simplifiée)&#10;      // Distance en km = 111.045 * sqrt((lat2-lat1)^2 + (cos(lat1)*(lon2-lon1))^2)&#10;      const distanceFormula = `&#10;        (111.045 * SQRT(&#10;          POW(lat - ${userLat}, 2) + &#10;          POW(COS(RADIANS(${userLat})) * (lon - ${userLon}), 2)&#10;        ))&#10;      `;&#10;      &#10;      // Requête avec distance calculée&#10;      const query = `&#10;        SELECT *, ${distanceFormula} as distance&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;        ORDER BY distance ASC&#10;        LIMIT ${limit} OFFSET ${offset}&#10;      `;&#10;      &#10;      const countQuery = `&#10;        SELECT COUNT(*) as count&#10;        FROM restaurants&#10;        ${whereClause}&#10;        AND lat IS NOT NULL &#10;        AND lon IS NOT NULL&#10;      `;&#10;      &#10;      try {&#10;        const results = await Promise.all([&#10;          prisma.$queryRawUnsafe(query, ...queryParams),&#10;          prisma.$queryRawUnsafe(countQuery, ...queryParams),&#10;        ]);&#10;&#10;        restaurants = results[0] as RestaurantRow[];&#10;        totalCount = Number((results[1] as Array&lt;{ count: bigint }&gt;)[0]?.count) || 0;&#10;      } catch (error) {&#10;        console.error('Erreur requête SQL distance:', error);&#10;        throw error;&#10;      }&#10;    } else {&#10;      // Tri par nom (ordre alphabétique)&#10;      const orderBy = sortBy === 'name' ? { name: 'asc' as const } : { name: 'asc' as const };&#10;      &#10;      [restaurants, totalCount] = await Promise.all([&#10;        prisma.restaurant.findMany({&#10;          where,&#10;          take: limit,&#10;          skip: offset,&#10;          orderBy,&#10;        }),&#10;        prisma.restaurant.count({ where }),&#10;      ]);&#10;    }&#10;    &#10;    // Transformation des données pour correspondre au format attendu&#10;    const results = restaurants.map((r: RestaurantRow) =&gt; ({&#10;      id: r.id.toString(),&#10;      name: r.name,&#10;      type: r.type,&#10;      cuisine: r.cuisine,&#10;      phone: r.phone,&#10;      website: r.website,&#10;      email: r.email,&#10;      street: r.street,&#10;      housenumber: r.housenumber,&#10;      postcode: r.postcode,&#10;      city: r.city,&#10;      region: r.region,&#10;      department: r.department,&#10;      opening_hours: r.opening_hours,&#10;      wheelchair: r.wheelchair,&#10;      delivery: r.delivery,&#10;      takeaway: r.takeaway,&#10;      outdoor_seating: r.outdoor_seating,&#10;      meta_geo_point: r.lat &amp;&amp; r.lon ? { lat: r.lat, lon: r.lon } : undefined,&#10;      osm_id: r.osm_id,&#10;      osm_type: r.osm_type,&#10;    }));&#10;    &#10;    return NextResponse.json({&#10;      total_count: totalCount,&#10;      results,&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error('Erreur API /api/restaurants:', error);&#10;    return NextResponse.json(&#10;      { error: 'Erreur lors de la récupération des restaurants' },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/components/Filters.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/components/Filters.tsx" />
              <option name="originalContent" value="/**&#10; * Composant Filters - Filtres de recherche (type, région, département, export)&#10; */&#10;&#10;'use client';&#10;&#10;import { useState } from 'react';&#10;import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';&#10;import { faChevronDown, faDownload, faRotateRight, faCircleInfo } from '@fortawesome/free-solid-svg-icons';&#10;import type { RestaurantType, FilterState, Restaurant } from '@/lib/types';&#10;import { exportToCSV } from '@/lib/utils';import { useCities, useDepartments } from '@/hooks/useRestaurantSearch';&#10;import { useRegions } from '@/hooks/useRestaurantSearch';&#10;interface FiltersProps {&#10;  filters: FilterState;&#10;  onFilterChange: (filters: FilterState) =&gt; void;&#10;  restaurants: Restaurant[];&#10;  totalCount: number;&#10;}&#10;&#10;const TYPES: { value: RestaurantType; label: string; emoji: string }[] = [&#10;  { value: '', label: 'Tous', emoji: '️' },&#10;  { value: 'restaurant', label: 'Restaurants', emoji: '' },&#10;  { value: 'bar', label: 'Bars', emoji: '' },&#10;  { value: 'cafe', label: 'Cafés', emoji: '☕' },&#10;  { value: 'fast_food', label: 'Fast Food', emoji: '' },&#10;  { value: 'pub', label: 'Pubs', emoji: '' },&#10;];&#10;&#10;export default function Filters({ filters, onFilterChange, restaurants, totalCount }: FiltersProps) {&#10;  const { data: regions = [] } = useRegions();&#10;  const handleTypeChange = (type: RestaurantType) =&gt; {&#10;    onFilterChange({ ...filters, type });&#10;  };&#10;&#10;  const handleRegionChange = (region: string) =&gt; {&#10;  const handleRegionChange = (region: string) =&gt; {&#10;    onFilterChange({ ...filters, region, department: '' });&#10;&#10;  const handleDepartmentChange = (department: string) =&gt; {&#10;    onFilterChange({ ...filters, department });&#10;  };&#10;&#10;  const handleLimitChange = (limitStr: string) =&gt; {&#10;    const limit = parseInt(limitStr, 10);&#10;    onFilterChange({ ...filters, limit });&#10;  };&#10;&#10;  const handleSortChange = (sortBy: string) =&gt; {&#10;    onFilterChange({ ...filters, sortBy: sortBy as 'distance' | 'name' | 'none' });&#10;  };&#10;&#10;  const handleExport = () =&gt; {&#10;    exportToCSV(restaurants);&#10;  };&#10;&#10;  const handleReset = () =&gt; {&#10;    onFilterChange({ type: '', region: '', department: '', limit: 5000, sortBy: 'none' });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;filter-card-dark rounded-lg shadow-sm p-4&quot;&gt;&#10;      {/* En-tête avec toggle mobile */}&#10;      &lt;div className=&quot;flex items-center justify-start lg:mb-0&quot;&gt;&#10;        &lt;button&#10;          onClick={() =&gt; setShowFilters(!showFilters)}&#10;          className=&quot;lg:hidden w-full text-start&quot;&#10;          style={{ color: 'var(--color-text)' }}&#10;          aria-label=&quot;Toggle filters&quot;&#10;        &gt;&#10;          &lt;FontAwesomeIcon &#10;            icon={faChevronDown} &#10;            className={`transition-transform mr-2 ${showFilters ? 'rotate-180' : ''}`}&#10;          /&gt;&#10;            Filtres&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Contenu des filtres */}&#10;      &lt;div className={`space-y-4 ${showFilters ? 'block mt-4' : 'hidden lg:block'}`}&gt;&#10;        {/* Types d'établissements */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;            Type d&amp;apos;établissement&#10;          &lt;/label&gt;&#10;          &lt;div className=&quot;flex flex-wrap gap-2 mb-3&quot;&gt;&#10;            {TYPES.map((type) =&gt; (&#10;              &lt;button&#10;                key={type.value}&#10;                onClick={() =&gt; handleTypeChange(type.value)}&#10;                className={`px-3 py-2 text-sm rounded-lg border transition-all ${&#10;                  filters.type === type.value&#10;                    ? 'text-white border-blue-600'&#10;                    : 'border-gray-300 hover:border-blue-400'&#10;                }`}&#10;                style={{&#10;                  backgroundColor: filters.type === type.value ? 'var(--color-primary)' : 'var(--color-surface-dark-3)',&#10;                  color: filters.type === type.value ? '#fff' : 'var(--color-text)',&#10;                  borderColor: filters.type === type.value ? 'var(--color-primary)' : 'var(--color-surface-outline)'&#10;                }}&#10;              &gt;&#10;                &lt;span className=&quot;mr-1&quot;&gt;{type.emoji}&lt;/span&gt;&#10;                {type.label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Région, Département, Tri et Limite */}&#10;        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-3&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;region&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Région&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;region&quot;&#10;              value={filters.region}&#10;              onChange={(e) =&gt; handleRegionChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;            &gt;&#10;              &lt;option value=&quot;&quot;&gt;Toutes les régions&lt;/option&gt;&#10;              {regions.map((region) =&gt; (&#10;                &lt;option key={region} value={region}&gt;&#10;                  {region}&#10;                &lt;/option&gt;&#10;              ))}&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;department&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Département&#10;            &lt;/label&gt;&#10;            &lt;input&#10;              type=&quot;text&quot;&#10;              id=&quot;department&quot;&#10;              value={filters.department}&#10;              onChange={(e) =&gt; handleDepartmentChange(e.target.value)}&#10;              placeholder=&quot;Ex: Paris, Bouches-du-Rhône&quot;&#10;              className=&quot;input&quot;&#10;            /&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;sortBy&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Trier par&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;sortBy&quot;&#10;              value={filters.sortBy || 'none'}&#10;              onChange={(e) =&gt; handleSortChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;            &gt;&#10;              &lt;option value=&quot;none&quot;&gt;Sans tri&lt;/option&gt;&#10;              &lt;option value=&quot;name&quot;&gt;Nom (A-Z)&lt;/option&gt;&#10;              &lt;option value=&quot;distance&quot;&gt;Distance (Géoloc)&lt;/option&gt;&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;limit&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Limite de résultats&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;limit&quot;&#10;              value={String(filters.limit ?? 5000)}&#10;              onChange={(e) =&gt; handleLimitChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;            &gt;&#10;              {[100, 250, 500, 1000, 2500, 5000].map((opt) =&gt; (&#10;                &lt;option key={opt} value={opt}&gt;{opt.toLocaleString('fr-FR')}&lt;/option&gt;&#10;              ))}&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Message info géolocalisation */}&#10;        {filters.sortBy === 'distance' &amp;&amp; (&#10;          &lt;div className=&quot;text-xs p-3 rounded-lg&quot; style={{ &#10;            backgroundColor: 'rgba(40, 83, 254, 0.1)', &#10;            border: '1px solid rgba(40, 83, 254, 0.3)',&#10;            color: 'rgba(255, 255, 255, 0.9)'&#10;          }}&gt;&#10;            &lt;div className=&quot;flex items-start gap-2&quot;&gt;&#10;              &lt;FontAwesomeIcon icon={faCircleInfo} className=&quot;h-4 w-4 mt-0.5 flex-shrink-0&quot; /&gt;&#10;              &lt;p&gt;&#10;                Le tri par distance utilise votre position actuelle. Autorisez la géolocalisation dans votre navigateur pour des résultats précis.&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Actions */}&#10;        &lt;div className=&quot;flex flex-wrap gap-2 mt-3&quot;&gt;&#10;          &lt;button&#10;            onClick={handleExport}&#10;            disabled={restaurants.length === 0}&#10;            className=&quot;flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-lg transition-colors disabled:cursor-not-allowed&quot;&#10;            style={{&#10;              backgroundColor: restaurants.length === 0 ? 'var(--color-surface-dark-3)' : 'var(--color-success)',&#10;              color: restaurants.length === 0 ? 'rgba(255,255,255,0.4)' : 'var(--color-secondary)',&#10;              opacity: restaurants.length === 0 ? 0.5 : 1&#10;            }}&#10;          &gt;&#10;            &lt;FontAwesomeIcon icon={faDownload} className=&quot;h-4 w-4&quot; /&gt;&#10;            Exporter CSV&#10;          &lt;/button&gt;&#10;&#10;          &lt;button&#10;            onClick={handleReset}&#10;            className=&quot;flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-lg border transition-colors&quot;&#10;            style={{&#10;              backgroundColor: 'var(--color-surface-dark-3)',&#10;              color: 'var(--color-text)',&#10;              borderColor: 'var(--color-surface-outline)'&#10;            }}&#10;          &gt;&#10;            &lt;FontAwesomeIcon icon={faRotateRight} className=&quot;h-4 w-4&quot; /&gt;&#10;            Réinitialiser&#10;          &lt;/button&gt;&#10;&#10;            &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                &lt;h3 className=&quot;text-sm font-semibold text-gray-700 m-0&quot;&gt;Filtres &lt;span className=&quot;text-xs text-gray-500&quot;&gt;&#10;            ({totalCount.toLocaleString('fr-FR')} résultat{totalCount &gt; 1 ? 's' : ''})&#10;          &lt;/span&gt;&lt;/h3&gt;&#10;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Composant Filters - Filtres de recherche (type, localisation, arrondissement, export)&#10; */&#10;&#10;'use client';&#10;&#10;import { useState } from 'react';&#10;import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';&#10;import { faChevronDown, faDownload, faRotateRight, faCircleInfo } from '@fortawesome/free-solid-svg-icons';&#10;import type { RestaurantType, FilterState, Restaurant } from '@/lib/types';&#10;import { exportToCSV } from '@/lib/utils';&#10;import { useLocations, useArrondissements } from '@/hooks/useRestaurantSearch';&#10;&#10;interface FiltersProps {&#10;  filters: FilterState;&#10;  onFilterChange: (filters: FilterState) =&gt; void;&#10;  restaurants: Restaurant[];&#10;  totalCount: number;&#10;}&#10;&#10;const TYPES: { value: RestaurantType; label: string; emoji: string }[] = [&#10;  { value: '', label: 'Tous', emoji: '️' },&#10;  { value: 'restaurant', label: 'Restaurants', emoji: '' },&#10;  { value: 'bar', label: 'Bars', emoji: '' },&#10;  { value: 'cafe', label: 'Cafés', emoji: '☕' },&#10;  { value: 'fast_food', label: 'Fast Food', emoji: '' },&#10;  { value: 'pub', label: 'Pubs', emoji: '' },&#10;];&#10;&#10;// Les 10 plus grandes villes de France par ordre de population&#10;const TOP_LOCATIONS = [&#10;  'Paris',&#10;  'Marseille',&#10;  'Lyon',&#10;  'Toulouse',&#10;  'Nice',&#10;  'Nantes',&#10;  'Montpellier',&#10;  'Strasbourg',&#10;  'Bordeaux',&#10;  'Lille'&#10;];&#10;&#10;export default function Filters({ filters, onFilterChange, restaurants, totalCount }: FiltersProps) {&#10;  const { data: locations = [] } = useLocations();&#10;  const { data: allArrondissements = [] } = useArrondissements();&#10;  const [showFilters, setShowFilters] = useState(false);&#10;&#10;  // Séparer les grandes villes du reste&#10;  const topLocationsAvailable = TOP_LOCATIONS.filter(loc =&gt; locations.includes(loc));&#10;  const otherLocations = locations.filter(loc =&gt; !TOP_LOCATIONS.includes(loc));&#10;&#10;  // Filtrer les arrondissements pour la localisation sélectionnée&#10;  const filteredArrondissements = filters.location &#10;    ? allArrondissements.filter(arr =&gt; arr.startsWith(filters.location + ' '))&#10;    : [];&#10;&#10;  const handleTypeChange = (type: RestaurantType) =&gt; {&#10;    onFilterChange({ ...filters, type });&#10;  };&#10;&#10;  const handleLocationChange = (location: string) =&gt; {&#10;    // Si on sélectionne une localisation, on désélectionne l'arrondissement&#10;    onFilterChange({ ...filters, location, arrondissement: '' });&#10;  };&#10;&#10;  const handleArrondissementChange = (arrondissement: string) =&gt; {&#10;    // Si on sélectionne un arrondissement, on garde la localisation pour le contexte&#10;    onFilterChange({ ...filters, arrondissement });&#10;  };&#10;&#10;  const handleLimitChange = (limitStr: string) =&gt; {&#10;    const limit = parseInt(limitStr, 10);&#10;    onFilterChange({ ...filters, limit });&#10;  };&#10;&#10;  const handleSortChange = (sortBy: string) =&gt; {&#10;    onFilterChange({ ...filters, sortBy: sortBy as 'distance' | 'name' | 'none' });&#10;  };&#10;&#10;  const handleExport = () =&gt; {&#10;    exportToCSV(restaurants);&#10;  };&#10;&#10;  const handleReset = () =&gt; {&#10;    onFilterChange({ type: '', location: '', arrondissement: '', limit: 5000, sortBy: 'none' });&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;filter-card-dark rounded-lg shadow-sm p-4&quot;&gt;&#10;      {/* En-tête avec toggle mobile */}&#10;      &lt;div className=&quot;flex items-center justify-start lg:mb-0&quot;&gt;&#10;        &lt;button&#10;          onClick={() =&gt; setShowFilters(!showFilters)}&#10;          className=&quot;lg:hidden w-full text-start&quot;&#10;          style={{ color: 'var(--color-text)' }}&#10;          aria-label=&quot;Toggle filters&quot;&#10;        &gt;&#10;          &lt;FontAwesomeIcon &#10;            icon={faChevronDown} &#10;            className={`transition-transform mr-2 ${showFilters ? 'rotate-180' : ''}`}&#10;          /&gt;&#10;            Filtres&#10;        &lt;/button&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Contenu des filtres */}&#10;      &lt;div className={`space-y-4 ${showFilters ? 'block mt-4' : 'hidden lg:block'}`}&gt;&#10;        {/* Types d'établissements */}&#10;        &lt;div&gt;&#10;          &lt;label className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;            Type d&amp;apos;établissement&#10;          &lt;/label&gt;&#10;          &lt;div className=&quot;flex flex-wrap gap-2 mb-3&quot;&gt;&#10;            {TYPES.map((type) =&gt; (&#10;              &lt;button&#10;                key={type.value}&#10;                onClick={() =&gt; handleTypeChange(type.value)}&#10;                className={`px-3 py-2 text-sm rounded-lg border transition-all ${&#10;                  filters.type === type.value&#10;                    ? 'text-white border-blue-600'&#10;                    : 'border-gray-300 hover:border-blue-400'&#10;                }`}&#10;                style={{&#10;                  backgroundColor: filters.type === type.value ? 'var(--color-primary)' : 'var(--color-surface-dark-3)',&#10;                  color: filters.type === type.value ? '#fff' : 'var(--color-text)',&#10;                  borderColor: filters.type === type.value ? 'var(--color-primary)' : 'var(--color-surface-outline)'&#10;                }}&#10;              &gt;&#10;                &lt;span className=&quot;mr-1&quot;&gt;{type.emoji}&lt;/span&gt;&#10;                {type.label}&#10;              &lt;/button&gt;&#10;            ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Localisation, Arrondissement, Tri et Limite */}&#10;        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-3&quot;&gt;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;location&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Ville / Département&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;location&quot;&#10;              value={filters.location || ''}&#10;              onChange={(e) =&gt; handleLocationChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;            &gt;&#10;              &lt;option value=&quot;&quot;&gt;Toutes les localisations&lt;/option&gt;&#10;              {topLocationsAvailable.length &gt; 0 &amp;&amp; (&#10;                &lt;&gt;&#10;                  {topLocationsAvailable.map((location) =&gt; (&#10;                    &lt;option key={location} value={location}&gt;&#10;                      ️ {location}&#10;                    &lt;/option&gt;&#10;                  ))}&#10;                  &lt;option disabled&gt;──────────&lt;/option&gt;&#10;                &lt;/&gt;&#10;              )}&#10;              {otherLocations.map((location) =&gt; (&#10;                &lt;option key={location} value={location}&gt;&#10;                  {location}&#10;                &lt;/option&gt;&#10;              ))}&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;arrondissement&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Arrondissement&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;arrondissement&quot;&#10;              value={filters.arrondissement || ''}&#10;              onChange={(e) =&gt; handleArrondissementChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;              disabled={!filters.location || filteredArrondissements.length === 0}&#10;            &gt;&#10;              &lt;option value=&quot;&quot;&gt;&#10;                {!filters.location &#10;                  ? 'Sélectionnez d\'abord une ville' &#10;                  : filteredArrondissements.length === 0 &#10;                    ? 'Pas d\'arrondissements'&#10;                    : 'Tous les arrondissements'}&#10;              &lt;/option&gt;&#10;              {filteredArrondissements.map((arr) =&gt; (&#10;                &lt;option key={arr} value={arr}&gt;&#10;                  {arr.replace(filters.location + ' ', '')}&#10;                &lt;/option&gt;&#10;              ))}&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;sortBy&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Trier par&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;sortBy&quot;&#10;              value={filters.sortBy || 'none'}&#10;              onChange={(e) =&gt; handleSortChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;            &gt;&#10;              &lt;option value=&quot;none&quot;&gt;Sans tri&lt;/option&gt;&#10;              &lt;option value=&quot;name&quot;&gt;Nom (A-Z)&lt;/option&gt;&#10;              &lt;option value=&quot;distance&quot;&gt;Distance (Géoloc)&lt;/option&gt;&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;&#10;          &lt;div&gt;&#10;            &lt;label htmlFor=&quot;limit&quot; className=&quot;block text-xs font-medium mb-2&quot; style={{ color: 'rgba(255, 255, 255, 0.85)' }}&gt;&#10;              Limite de résultats&#10;            &lt;/label&gt;&#10;            &lt;select&#10;              id=&quot;limit&quot;&#10;              value={String(filters.limit ?? 5000)}&#10;              onChange={(e) =&gt; handleLimitChange(e.target.value)}&#10;              className=&quot;select&quot;&#10;            &gt;&#10;              {[100, 250, 500, 1000, 2500, 5000].map((opt) =&gt; (&#10;                &lt;option key={opt} value={opt}&gt;{opt.toLocaleString('fr-FR')}&lt;/option&gt;&#10;              ))}&#10;            &lt;/select&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Message info géolocalisation */}&#10;        {filters.sortBy === 'distance' &amp;&amp; (&#10;          &lt;div className=&quot;text-xs p-3 rounded-lg&quot; style={{ &#10;            backgroundColor: 'rgba(40, 83, 254, 0.1)', &#10;            border: '1px solid rgba(40, 83, 254, 0.3)',&#10;            color: 'rgba(255, 255, 255, 0.9)'&#10;          }}&gt;&#10;            &lt;div className=&quot;flex items-start gap-2&quot;&gt;&#10;              &lt;FontAwesomeIcon icon={faCircleInfo} className=&quot;h-4 w-4 mt-0.5 flex-shrink-0&quot; /&gt;&#10;              &lt;p&gt;&#10;                Le tri par distance utilise votre position actuelle. Autorisez la géolocalisation dans votre navigateur pour des résultats précis.&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        {/* Actions */}&#10;        &lt;div className=&quot;flex flex-wrap gap-2 mt-3&quot;&gt;&#10;          &lt;button&#10;            onClick={handleExport}&#10;            disabled={restaurants.length === 0}&#10;            className=&quot;flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-lg transition-colors disabled:cursor-not-allowed&quot;&#10;            style={{&#10;              backgroundColor: restaurants.length === 0 ? 'var(--color-surface-dark-3)' : 'var(--color-success)',&#10;              color: restaurants.length === 0 ? 'rgba(255,255,255,0.4)' : 'var(--color-secondary)',&#10;              opacity: restaurants.length === 0 ? 0.5 : 1&#10;            }}&#10;          &gt;&#10;            &lt;FontAwesomeIcon icon={faDownload} className=&quot;h-4 w-4&quot; /&gt;&#10;            Exporter CSV&#10;          &lt;/button&gt;&#10;&#10;          &lt;button&#10;            onClick={handleReset}&#10;            className=&quot;flex items-center gap-2 px-4 py-2 text-sm font-medium rounded-lg border transition-colors&quot;&#10;            style={{&#10;              backgroundColor: 'var(--color-surface-dark-3)',&#10;              color: 'var(--color-text)',&#10;              borderColor: 'var(--color-surface-outline)'&#10;            }}&#10;          &gt;&#10;            &lt;FontAwesomeIcon icon={faRotateRight} className=&quot;h-4 w-4&quot; /&gt;&#10;            Réinitialiser&#10;          &lt;/button&gt;&#10;&#10;            &lt;div className=&quot;flex items-center gap-2&quot;&gt;&#10;                &lt;h3 className=&quot;text-sm font-semibold text-gray-700 m-0&quot;&gt;Filtres &lt;span className=&quot;text-xs text-gray-500&quot;&gt;&#10;            ({totalCount.toLocaleString('fr-FR')} résultat{totalCount &gt; 1 ? 's' : ''})&#10;          &lt;/span&gt;&lt;/h3&gt;&#10;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/page.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/page.tsx" />
              <option name="originalContent" value="/**&#10; * Page principale - Juice Finder France&#10; */&#10;&#10;'use client';&#10;&#10;import { useState, useMemo, useEffect } from 'react';&#10;import Image from &quot;next/image&quot;;&#10;import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';&#10;import { faCircleXmark } from '@fortawesome/free-solid-svg-icons';&#10;import SearchBar from './components/SearchBar';&#10;import Filters from './components/Filters';&#10;import MapView from './components/MapView';&#10;import ResultsList from './components/ResultsList';&#10;import UpdateButton from './components/UpdateButton';&#10;import { useRestaurantSearch } from '@/hooks/useRestaurantSearch';&#10;import type { FilterState, Restaurant } from '@/lib/types';&#10;&#10;export default function HomePage() {&#10;  const [searchTerm, setSearchTerm] = useState('');&#10;  const [filters, setFilters] = useState&lt;FilterState&gt;({&#10;    type: 'restaurant',&#10;    region: '',&#10;    department: 'Paris', // Par défaut : Paris&#10;    limit: 500, // Limite par défaut&#10;    sortBy: &quot;distance&quot;, // Tri par défaut&#10;  });&#10;  const [selectedRestaurant, setSelectedRestaurant] = useState&lt;Restaurant | undefined&gt;();&#10;  const [userLocation, setUserLocation] = useState&lt;{ lat: number; lon: number } | null&gt;(null);&#10;  // Géolocalisation de l'utilisateur&#10;  useEffect(() =&gt; {&#10;    if (navigator.geolocation) {&#10;      navigator.geolocation.getCurrentPosition(&#10;        (position) =&gt; {&#10;          setUserLocation({&#10;            lat: position.coords.latitude,&#10;            lon: position.coords.longitude,&#10;          });&#10;        },&#10;        (error) =&gt; {&#10;          console.log('Géolocalisation non disponible:', error);&#10;        }&#10;      );&#10;    }&#10;  }, []);&#10;&#10;  // Hook de recherche avec TanStack Query&#10;  const {&#10;    data,&#10;    isLoading,&#10;    isError,&#10;    error,&#10;    fetchNextPage,&#10;    hasNextPage,&#10;    isFetchingNextPage,&#10;  } = useRestaurantSearch({&#10;    searchTerm,&#10;    type: filters.type,&#10;    region: filters.region,&#10;    department: filters.department,&#10;    limit: filters.limit ?? 5000,&#10;    sortBy: filters.sortBy,&#10;    userLat: userLocation?.lat,&#10;    userLon: userLocation?.lon,&#10;  });&#10;&#10;  // Agrège tous les restaurants des pages (le tri est fait côté serveur)&#10;  const allRestaurants = useMemo(() =&gt; {&#10;    if (!data?.pages) return [];&#10;    return data.pages.flatMap(page =&gt; page.results);&#10;  }, [data]);&#10;&#10;  const totalCount = data?.pages[0]?.total_count || 0;&#10;&#10;  const handleSelectRestaurant = (restaurant: Restaurant) =&gt; {&#10;    setSelectedRestaurant(restaurant);&#10;    &#10;    // Scroll vers la carte sur mobile&#10;    if (window.innerWidth &lt; 1024) {&#10;      const mapElement = document.getElementById('map-container');&#10;      if (mapElement) {&#10;        mapElement.scrollIntoView({ behavior: 'smooth', block: 'start' });&#10;      }&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen&quot; style={{ backgroundColor: 'var(--background)' }}&gt;&#10;      {/* Lien d'évitement pour l'accessibilité */}&#10;      &lt;a href=&quot;#main&quot; className=&quot;sr-only focus:not-sr-only focus:absolute focus:top-2 focus:left-2 focus:z-50 bg-white border border-gray-300 rounded px-3 py-2 text-sm&quot;&gt;&#10;        Aller au contenu&#10;      &lt;/a&gt;&#10;&#10;      {/* Header */}&#10;      &lt;header role=&quot;banner&quot; className=&quot;header-gradient header-gradient-border sticky top-0 z-40&quot;&gt;&#10;        &lt;div className=&quot;container py-4&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-center mb-4&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;h1 className=&quot;text-2xl lg:text-3xl font-bold flex items-center&quot; style={{ color: 'var(--color-text)' }}&gt;&#10;                &lt;Image &#10;                  src=&quot;/assets/img/juice@4x.png&quot; &#10;                  alt=&quot;Juice Finder Logo&quot; &#10;                  height={40} &#10;                  width={200} &#10;                  className=&quot;mr-2&quot;&#10;                /&gt;&#10;                &lt;span className=&quot;logo-finder&quot;&gt;FINDER&lt;/span&gt;&#10;              &lt;/h1&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          {/* Barre de recherche */}&#10;          &lt;nav aria-label=&quot;Recherche&quot;&gt;&#10;            &lt;SearchBar onSearch={setSearchTerm} /&gt;&#10;          &lt;/nav&gt;&#10;        &lt;/div&gt;&#10;      &lt;/header&gt;&#10;&#10;      {/* Main Content */}&#10;      &lt;main id=&quot;main&quot; role=&quot;main&quot;&gt;&#10;        &lt;div className=&quot;container py-6&quot;&gt;&#10;          {/* Filtres */}&#10;          &lt;section aria-labelledby=&quot;filtres-titre&quot; className=&quot;mb-6&quot;&gt;&#10;            &lt;h2 id=&quot;filtres-titre&quot; className=&quot;sr-only&quot;&gt;Filtres&lt;/h2&gt;&#10;            &lt;Filters&#10;              filters={filters}&#10;              onFilterChange={setFilters}&#10;              restaurants={allRestaurants}&#10;              totalCount={totalCount}&#10;            /&gt;&#10;          &lt;/section&gt;&#10;&#10;          {/* Erreur */}&#10;          {isError &amp;&amp; (&#10;            &lt;div className=&quot;mb-6 bg-red-50 border border-red-200 rounded-lg p-4&quot; role=&quot;alert&quot;&gt;&#10;              &lt;div className=&quot;flex items-start gap-3&quot;&gt;&#10;                &lt;FontAwesomeIcon &#10;                  icon={faCircleXmark} &#10;                  className=&quot;h-5 w-5 text-red-600 flex-shrink-0 mt-0.5&quot;&#10;                  aria-hidden=&quot;true&quot;&#10;                /&gt;&#10;                &lt;div&gt;&#10;                  &lt;h3 className=&quot;text-sm font-medium text-red-800&quot;&gt;Erreur lors de la recherche&lt;/h3&gt;&#10;                  &lt;p className=&quot;text-sm text-red-700 mt-1&quot;&gt;&#10;                    {error?.message || 'Une erreur inattendue s\'est produite'}&#10;                  &lt;/p&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* Layout Desktop/Mobile */}&#10;          &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;&#10;            {/* Carte */}&#10;            &lt;aside id=&quot;map-container&quot; className=&quot;order-1 lg:order-2&quot; role=&quot;complementary&quot; aria-label=&quot;Carte des restaurants&quot;&gt;&#10;              &lt;div className=&quot;sticky top-24&quot;&gt;&#10;                &lt;MapView&#10;                  restaurants={allRestaurants}&#10;                  selectedRestaurant={selectedRestaurant}&#10;                  onRestaurantSelect={handleSelectRestaurant}&#10;                /&gt;&#10;              &lt;/div&gt;&#10;            &lt;/aside&gt;&#10;&#10;            {/* Liste des résultats */}&#10;            &lt;section className=&quot;order-2 lg:order-1&quot; aria-labelledby=&quot;resultats-titre&quot;&gt;&#10;              &lt;h2 id=&quot;resultats-titre&quot; className=&quot;sr-only&quot;&gt;Résultats&lt;/h2&gt;&#10;              {(!isLoading &amp;&amp; allRestaurants.length === 0) ? (&#10;                &lt;div className=&quot;bg-white border border-gray-200 rounded-lg p-6 text-center&quot;&gt;&#10;                  &lt;p className=&quot;text-sm text-gray-600&quot;&gt;Aucun résultat. Modifiez les filtres pour élargir la recherche.&lt;/p&gt;&#10;                &lt;/div&gt;&#10;              ) : (&#10;                &lt;ResultsList&#10;                  restaurants={allRestaurants}&#10;                  isLoading={isLoading}&#10;                  isFetchingNextPage={isFetchingNextPage}&#10;                  hasNextPage={hasNextPage || false}&#10;                  onLoadMore={fetchNextPage}&#10;                  onSelectRestaurant={handleSelectRestaurant}&#10;                  selectedRestaurantId={selectedRestaurant?.id}&#10;                  userLocation={userLocation}&#10;                  sortBy={filters.sortBy}&#10;                /&gt;&#10;              )}&#10;            &lt;/section&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/main&gt;&#10;&#10;      {/* Footer */}&#10;      {/*&lt;footer role=&quot;contentinfo&quot; className=&quot;bg-white border-t border-gray-200 mt-12&quot;&gt;*/}&#10;      {/*  &lt;div className=&quot;container py-8&quot;&gt;*/}&#10;      {/*    &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;*/}&#10;      {/*      &lt;section aria-labelledby=&quot;a-propos-titre&quot;&gt;*/}&#10;      {/*        &lt;h2 id=&quot;a-propos-titre&quot; className=&quot;text-sm font-semibold text-gray-900 mb-3&quot;&gt;À propos&lt;/h2&gt;*/}&#10;      {/*        &lt;p className=&quot;text-sm text-gray-600&quot;&gt;*/}&#10;      {/*          Juice Finder France vous aide à découvrir des restaurants, bars et cafés */}&#10;      {/*          partout en France grâce aux données ouvertes d&amp;apos;OpenStreetMap.*/}&#10;      {/*        &lt;/p&gt;*/}&#10;      {/*      &lt;/section&gt;*/}&#10;      {/*      &lt;section aria-labelledby=&quot;sources-titre&quot;&gt;*/}&#10;      {/*        &lt;h2 id=&quot;sources-titre&quot; className=&quot;text-sm font-semibold text-gray-900 mb-3&quot;&gt;Sources de données&lt;/h2&gt;*/}&#10;      {/*        &lt;ul className=&quot;space-y-2 text-sm text-gray-600&quot;&gt;*/}&#10;      {/*          &lt;li&gt;*/}&#10;      {/*            &lt;a*/}&#10;      {/*              href=&quot;https://www.openstreetmap.org/&quot;*/}&#10;      {/*              target=&quot;_blank&quot;*/}&#10;      {/*              rel=&quot;noopener noreferrer&quot;*/}&#10;      {/*              className=&quot;hover:text-blue-600 hover:underline&quot;*/}&#10;      {/*            &gt;*/}&#10;      {/*              © OpenStreetMap contributors*/}&#10;      {/*            &lt;/a&gt;*/}&#10;      {/*          &lt;/li&gt;*/}&#10;      {/*          &lt;li&gt;*/}&#10;      {/*            &lt;a*/}&#10;      {/*              href=&quot;https://public.opendatasoft.com/&quot;*/}&#10;      {/*              target=&quot;_blank&quot;*/}&#10;      {/*              rel=&quot;noopener noreferrer&quot;*/}&#10;      {/*              className=&quot;hover:text-blue-600 hover:underline&quot;*/}&#10;      {/*            &gt;*/}&#10;      {/*              Données OpenDataSoft*/}&#10;      {/*            &lt;/a&gt;*/}&#10;      {/*          &lt;/li&gt;*/}&#10;      {/*        &lt;/ul&gt;*/}&#10;      {/*      &lt;/section&gt;*/}&#10;      {/*    &lt;/div&gt;*/}&#10;      {/*    &lt;div className=&quot;mt-8 pt-6 border-t border-gray-200 text-center&quot;&gt;*/}&#10;      {/*      &lt;p className=&quot;text-xs text-gray-500&quot;&gt;*/}&#10;      {/*        © {new Date().getFullYear()} Juice Finder France. Construit avec Next.js, TypeScript et TanStack Query.*/}&#10;      {/*      &lt;/p&gt;*/}&#10;      {/*    &lt;/div&gt;*/}&#10;      {/*  &lt;/div&gt;*/}&#10;      {/*&lt;/footer&gt;*/}&#10;&#10;      {/* Bouton de mise à jour de la base */}&#10;      &lt;UpdateButton /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Page principale - Juice Finder France&#10; */&#10;&#10;'use client';&#10;&#10;import { useState, useMemo, useEffect } from 'react';&#10;import Image from &quot;next/image&quot;;&#10;import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';&#10;import { faCircleXmark } from '@fortawesome/free-solid-svg-icons';&#10;import SearchBar from './components/SearchBar';&#10;import Filters from './components/Filters';&#10;import MapView from './components/MapView';&#10;import ResultsList from './components/ResultsList';&#10;import UpdateButton from './components/UpdateButton';&#10;import { useRestaurantSearch } from '@/hooks/useRestaurantSearch';&#10;import type { FilterState, Restaurant } from '@/lib/types';&#10;&#10;export default function HomePage() {&#10;  const [searchTerm, setSearchTerm] = useState('');&#10;  const [filters, setFilters] = useState&lt;FilterState&gt;({&#10;    type: 'restaurant',&#10;    location: 'Paris', &#10;    arrondissement: '', // Par défaut : vide&#10;    limit: 500, // Limite par défaut&#10;    sortBy: &quot;distance&quot;, // Tri par défaut&#10;  });&#10;  const [selectedRestaurant, setSelectedRestaurant] = useState&lt;Restaurant | undefined&gt;();&#10;  const [userLocation, setUserLocation] = useState&lt;{ lat: number; lon: number } | null&gt;(null);&#10;  // Géolocalisation de l'utilisateur&#10;  useEffect(() =&gt; {&#10;    if (navigator.geolocation) {&#10;      navigator.geolocation.getCurrentPosition(&#10;        (position) =&gt; {&#10;          setUserLocation({&#10;            lat: position.coords.latitude,&#10;            lon: position.coords.longitude,&#10;          });&#10;        },&#10;        (error) =&gt; {&#10;          console.log('Géolocalisation non disponible:', error);&#10;        }&#10;      );&#10;    }&#10;  }, []);&#10;&#10;  // Hook de recherche avec TanStack Query&#10;  const {&#10;    data,&#10;    isLoading,&#10;    isError,&#10;    error,&#10;    fetchNextPage,&#10;    hasNextPage,&#10;    isFetchingNextPage,&#10;  } = useRestaurantSearch({&#10;    searchTerm,&#10;    type: filters.type,&#10;    location: filters.location,&#10;    arrondissement: filters.arrondissement,&#10;    limit: filters.limit ?? 5000,&#10;    sortBy: filters.sortBy,&#10;    userLat: userLocation?.lat,&#10;    userLon: userLocation?.lon,&#10;  });&#10;&#10;  // Agrège tous les restaurants des pages (le tri est fait côté serveur)&#10;  const allRestaurants = useMemo(() =&gt; {&#10;    if (!data?.pages) return [];&#10;    return data.pages.flatMap(page =&gt; page.results);&#10;  }, [data]);&#10;&#10;  const totalCount = data?.pages[0]?.total_count || 0;&#10;&#10;  const handleSelectRestaurant = (restaurant: Restaurant) =&gt; {&#10;    setSelectedRestaurant(restaurant);&#10;    &#10;    // Scroll vers la carte sur mobile&#10;    if (window.innerWidth &lt; 1024) {&#10;      const mapElement = document.getElementById('map-container');&#10;      if (mapElement) {&#10;        mapElement.scrollIntoView({ behavior: 'smooth', block: 'start' });&#10;      }&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen&quot; style={{ backgroundColor: 'var(--background)' }}&gt;&#10;      {/* Lien d'évitement pour l'accessibilité */}&#10;      &lt;a href=&quot;#main&quot; className=&quot;sr-only focus:not-sr-only focus:absolute focus:top-2 focus:left-2 focus:z-50 bg-white border border-gray-300 rounded px-3 py-2 text-sm&quot;&gt;&#10;        Aller au contenu&#10;      &lt;/a&gt;&#10;&#10;      {/* Header */}&#10;      &lt;header role=&quot;banner&quot; className=&quot;header-gradient header-gradient-border sticky top-0 z-40&quot;&gt;&#10;        &lt;div className=&quot;container py-4&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-center mb-4&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;h1 className=&quot;text-2xl lg:text-3xl font-bold flex items-center&quot; style={{ color: 'var(--color-text)' }}&gt;&#10;                &lt;Image &#10;                  src=&quot;/assets/img/juice@4x.png&quot; &#10;                  alt=&quot;Juice Finder Logo&quot; &#10;                  height={40} &#10;                  width={200} &#10;                  className=&quot;mr-2&quot;&#10;                /&gt;&#10;                &lt;span className=&quot;logo-finder&quot;&gt;FINDER&lt;/span&gt;&#10;              &lt;/h1&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;          {/* Barre de recherche */}&#10;          &lt;nav aria-label=&quot;Recherche&quot;&gt;&#10;            &lt;SearchBar onSearch={setSearchTerm} /&gt;&#10;          &lt;/nav&gt;&#10;        &lt;/div&gt;&#10;      &lt;/header&gt;&#10;&#10;      {/* Main Content */}&#10;      &lt;main id=&quot;main&quot; role=&quot;main&quot;&gt;&#10;        &lt;div className=&quot;container py-6&quot;&gt;&#10;          {/* Filtres */}&#10;          &lt;section aria-labelledby=&quot;filtres-titre&quot; className=&quot;mb-6&quot;&gt;&#10;            &lt;h2 id=&quot;filtres-titre&quot; className=&quot;sr-only&quot;&gt;Filtres&lt;/h2&gt;&#10;            &lt;Filters&#10;              filters={filters}&#10;              onFilterChange={setFilters}&#10;              restaurants={allRestaurants}&#10;              totalCount={totalCount}&#10;            /&gt;&#10;          &lt;/section&gt;&#10;&#10;          {/* Erreur */}&#10;          {isError &amp;&amp; (&#10;            &lt;div className=&quot;mb-6 bg-red-50 border border-red-200 rounded-lg p-4&quot; role=&quot;alert&quot;&gt;&#10;              &lt;div className=&quot;flex items-start gap-3&quot;&gt;&#10;                &lt;FontAwesomeIcon &#10;                  icon={faCircleXmark} &#10;                  className=&quot;h-5 w-5 text-red-600 flex-shrink-0 mt-0.5&quot;&#10;                  aria-hidden=&quot;true&quot;&#10;                /&gt;&#10;                &lt;div&gt;&#10;                  &lt;h3 className=&quot;text-sm font-medium text-red-800&quot;&gt;Erreur lors de la recherche&lt;/h3&gt;&#10;                  &lt;p className=&quot;text-sm text-red-700 mt-1&quot;&gt;&#10;                    {error?.message || 'Une erreur inattendue s\'est produite'}&#10;                  &lt;/p&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* Layout Desktop/Mobile */}&#10;          &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-6&quot;&gt;&#10;            {/* Carte */}&#10;            &lt;aside id=&quot;map-container&quot; className=&quot;order-1 lg:order-2&quot; role=&quot;complementary&quot; aria-label=&quot;Carte des restaurants&quot;&gt;&#10;              &lt;div className=&quot;sticky top-24&quot;&gt;&#10;                &lt;MapView&#10;                  restaurants={allRestaurants}&#10;                  selectedRestaurant={selectedRestaurant}&#10;                  onRestaurantSelect={handleSelectRestaurant}&#10;                /&gt;&#10;              &lt;/div&gt;&#10;            &lt;/aside&gt;&#10;&#10;            {/* Liste des résultats */}&#10;            &lt;section className=&quot;order-2 lg:order-1&quot; aria-labelledby=&quot;resultats-titre&quot;&gt;&#10;              &lt;h2 id=&quot;resultats-titre&quot; className=&quot;sr-only&quot;&gt;Résultats&lt;/h2&gt;&#10;              {(!isLoading &amp;&amp; allRestaurants.length === 0) ? (&#10;                &lt;div className=&quot;bg-white border border-gray-200 rounded-lg p-6 text-center&quot;&gt;&#10;                  &lt;p className=&quot;text-sm text-gray-600&quot;&gt;Aucun résultat. Modifiez les filtres pour élargir la recherche.&lt;/p&gt;&#10;                &lt;/div&gt;&#10;              ) : (&#10;                &lt;ResultsList&#10;                  restaurants={allRestaurants}&#10;                  isLoading={isLoading}&#10;                  isFetchingNextPage={isFetchingNextPage}&#10;                  hasNextPage={hasNextPage || false}&#10;                  onLoadMore={fetchNextPage}&#10;                  onSelectRestaurant={handleSelectRestaurant}&#10;                  selectedRestaurantId={selectedRestaurant?.id}&#10;                  userLocation={userLocation}&#10;                  sortBy={filters.sortBy}&#10;                /&gt;&#10;              )}&#10;            &lt;/section&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/main&gt;&#10;&#10;      {/* Footer */}&#10;      {/*&lt;footer role=&quot;contentinfo&quot; className=&quot;bg-white border-t border-gray-200 mt-12&quot;&gt;*/}&#10;      {/*  &lt;div className=&quot;container py-8&quot;&gt;*/}&#10;      {/*    &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;*/}&#10;      {/*      &lt;section aria-labelledby=&quot;a-propos-titre&quot;&gt;*/}&#10;      {/*        &lt;h2 id=&quot;a-propos-titre&quot; className=&quot;text-sm font-semibold text-gray-900 mb-3&quot;&gt;À propos&lt;/h2&gt;*/}&#10;      {/*        &lt;p className=&quot;text-sm text-gray-600&quot;&gt;*/}&#10;      {/*          Juice Finder France vous aide à découvrir des restaurants, bars et cafés */}&#10;      {/*          partout en France grâce aux données ouvertes d&amp;apos;OpenStreetMap.*/}&#10;      {/*        &lt;/p&gt;*/}&#10;      {/*      &lt;/section&gt;*/}&#10;      {/*      &lt;section aria-labelledby=&quot;sources-titre&quot;&gt;*/}&#10;      {/*        &lt;h2 id=&quot;sources-titre&quot; className=&quot;text-sm font-semibold text-gray-900 mb-3&quot;&gt;Sources de données&lt;/h2&gt;*/}&#10;      {/*        &lt;ul className=&quot;space-y-2 text-sm text-gray-600&quot;&gt;*/}&#10;      {/*          &lt;li&gt;*/}&#10;      {/*            &lt;a*/}&#10;      {/*              href=&quot;https://www.openstreetmap.org/&quot;*/}&#10;      {/*              target=&quot;_blank&quot;*/}&#10;      {/*              rel=&quot;noopener noreferrer&quot;*/}&#10;      {/*              className=&quot;hover:text-blue-600 hover:underline&quot;*/}&#10;      {/*            &gt;*/}&#10;      {/*              © OpenStreetMap contributors*/}&#10;      {/*            &lt;/a&gt;*/}&#10;      {/*          &lt;/li&gt;*/}&#10;      {/*          &lt;li&gt;*/}&#10;      {/*            &lt;a*/}&#10;      {/*              href=&quot;https://public.opendatasoft.com/&quot;*/}&#10;      {/*              target=&quot;_blank&quot;*/}&#10;      {/*              rel=&quot;noopener noreferrer&quot;*/}&#10;      {/*              className=&quot;hover:text-blue-600 hover:underline&quot;*/}&#10;      {/*            &gt;*/}&#10;      {/*              Données OpenDataSoft*/}&#10;      {/*            &lt;/a&gt;*/}&#10;      {/*          &lt;/li&gt;*/}&#10;      {/*        &lt;/ul&gt;*/}&#10;      {/*      &lt;/section&gt;*/}&#10;      {/*    &lt;/div&gt;*/}&#10;      {/*    &lt;div className=&quot;mt-8 pt-6 border-t border-gray-200 text-center&quot;&gt;*/}&#10;      {/*      &lt;p className=&quot;text-xs text-gray-500&quot;&gt;*/}&#10;      {/*        © {new Date().getFullYear()} Juice Finder France. Construit avec Next.js, TypeScript et TanStack Query.*/}&#10;      {/*      &lt;/p&gt;*/}&#10;      {/*    &lt;/div&gt;*/}&#10;      {/*  &lt;/div&gt;*/}&#10;      {/*&lt;/footer&gt;*/}&#10;&#10;      {/* Bouton de mise à jour de la base */}&#10;      &lt;UpdateButton /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/hooks/useRestaurantSearch.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/hooks/useRestaurantSearch.ts" />
              <option name="originalContent" value="/**&#10; * Hook TanStack Query pour la recherche de restaurants&#10; */&#10;&#10;'use client';&#10;&#10;import { useQuery, useInfiniteQuery } from '@tanstack/react-query';&#10;import { fetchRestaurants, fetchRegions, fetchDepartments } from '@/lib/api';&#10;import type { SearchParams, ApiResponse } from '@/lib/types';&#10;&#10;/**&#10; * Hook pour rechercher des restaurants avec pagination&#10; */&#10;export function useRestaurantSearch(params: SearchParams) {&#10;  // Si limit &gt; 100, on charge tout d'un coup sans pagination&#10;  const useSimpleQuery = (params.limit || 20) &gt; 100;&#10;  &#10;  const simpleQueryResult = useQuery&lt;ApiResponse, Error&gt;({&#10;    queryKey: ['restaurants-simple', params],&#10;    queryFn: () =&gt; fetchRestaurants(params),&#10;    staleTime: 1000 * 60 * 5,&#10;    retry: 2,&#10;    enabled: useSimpleQuery,&#10;  });&#10;  &#10;  const infiniteQueryResult = useInfiniteQuery&lt;ApiResponse, Error&gt;({&#10;    queryKey: ['restaurants-infinite', params],&#10;    queryFn: async ({ pageParam = 0 }) =&gt; {&#10;      return fetchRestaurants({&#10;        ...params,&#10;        offset: pageParam as number,&#10;      });&#10;    },&#10;    getNextPageParam: (lastPage, allPages) =&gt; {&#10;      const currentOffset = allPages.length * (params.limit || 20);&#10;      &#10;      if (currentOffset &gt;= lastPage.total_count) {&#10;        return undefined;&#10;      }&#10;      &#10;      return currentOffset;&#10;    },&#10;    initialPageParam: 0,&#10;    staleTime: 1000 * 60 * 5,&#10;    retry: 2,&#10;    enabled: !useSimpleQuery,&#10;  });&#10;  &#10;  // Adapter le résultat simple pour correspondre à l'interface infinie&#10;  if (useSimpleQuery) {&#10;    return {&#10;      data: simpleQueryResult.data ? {&#10;        pages: [simpleQueryResult.data],&#10;        pageParams: [0],&#10;      } : undefined,&#10;      isLoading: simpleQueryResult.isLoading,&#10;      isError: simpleQueryResult.isError,&#10;      error: simpleQueryResult.error,&#10;      fetchNextPage: async () =&gt; ({ data: undefined, error: null, isError: false, isSuccess: true }),&#10;      hasNextPage: false,&#10;      isFetchingNextPage: false,&#10;      refetch: simpleQueryResult.refetch,&#10;    };&#10;  }&#10;  &#10;  return infiniteQueryResult;&#10;}&#10;&#10;/**&#10; * Hook pour récupérer la liste des régions&#10; */&#10;export function useRegions() {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['regions'],&#10;    queryFn: fetchRegions,&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;/**&#10; * Hook pour récupérer les départements d'une région&#10; */&#10;export function useDepartments(region?: string) {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['departments', region],&#10;    queryFn: () =&gt; fetchDepartments(region),&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    enabled: !!region, // Ne s'exécute que si une région est sélectionnée&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * Hook TanStack Query pour la recherche de restaurants&#10; */&#10;&#10;'use client';&#10;&#10;import { useQuery, useInfiniteQuery } from '@tanstack/react-query';&#10;import { fetchRestaurants, fetchRegions, fetchDepartments, fetchCities, fetchLocations, fetchArrondissements } from '@/lib/api';&#10;import type { SearchParams, ApiResponse } from '@/lib/types';&#10;&#10;/**&#10; * Hook pour rechercher des restaurants avec pagination&#10; */&#10;export function useRestaurantSearch(params: SearchParams) {&#10;  // Si limit &gt; 100, on charge tout d'un coup sans pagination&#10;  const useSimpleQuery = (params.limit || 20) &gt; 100;&#10;  &#10;  const simpleQueryResult = useQuery&lt;ApiResponse, Error&gt;({&#10;    queryKey: ['restaurants-simple', params],&#10;    queryFn: () =&gt; fetchRestaurants(params),&#10;    staleTime: 1000 * 60 * 5,&#10;    retry: 2,&#10;    enabled: useSimpleQuery,&#10;  });&#10;  &#10;  const infiniteQueryResult = useInfiniteQuery&lt;ApiResponse, Error&gt;({&#10;    queryKey: ['restaurants-infinite', params],&#10;    queryFn: async ({ pageParam = 0 }) =&gt; {&#10;      return fetchRestaurants({&#10;        ...params,&#10;        offset: pageParam as number,&#10;      });&#10;    },&#10;    getNextPageParam: (lastPage, allPages) =&gt; {&#10;      const currentOffset = allPages.length * (params.limit || 20);&#10;      &#10;      if (currentOffset &gt;= lastPage.total_count) {&#10;        return undefined;&#10;      }&#10;      &#10;      return currentOffset;&#10;    },&#10;    initialPageParam: 0,&#10;    staleTime: 1000 * 60 * 5,&#10;    retry: 2,&#10;    enabled: !useSimpleQuery,&#10;  });&#10;  &#10;  // Adapter le résultat simple pour correspondre à l'interface infinie&#10;  if (useSimpleQuery) {&#10;    return {&#10;      data: simpleQueryResult.data ? {&#10;        pages: [simpleQueryResult.data],&#10;        pageParams: [0],&#10;      } : undefined,&#10;      isLoading: simpleQueryResult.isLoading,&#10;      isError: simpleQueryResult.isError,&#10;      error: simpleQueryResult.error,&#10;      fetchNextPage: async () =&gt; ({ data: undefined, error: null, isError: false, isSuccess: true }),&#10;      hasNextPage: false,&#10;      isFetchingNextPage: false,&#10;      refetch: simpleQueryResult.refetch,&#10;    };&#10;  }&#10;  &#10;  return infiniteQueryResult;&#10;}&#10;&#10;/**&#10; * Hook pour récupérer la liste des régions&#10; */&#10;export function useRegions() {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['regions'],&#10;    queryFn: fetchRegions,&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;/**&#10; * Hook pour récupérer la liste des localisations (villes + départements)&#10; */&#10;export function useLocations() {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['locations'],&#10;    queryFn: fetchLocations,&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;/**&#10; * Hook pour récupérer la liste des arrondissements&#10; */&#10;export function useArrondissements() {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['arrondissements'],&#10;    queryFn: fetchArrondissements,&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;/**&#10; * Hook pour récupérer la liste des villes&#10; */&#10;export function useCities() {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['cities'],&#10;    queryFn: fetchCities,&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;/**&#10; * Hook pour récupérer la liste des départements&#10; */&#10;export function useDepartments() {&#10;  return useQuery&lt;string[], Error&gt;({&#10;    queryKey: ['departments'],&#10;    queryFn: fetchDepartments,&#10;    staleTime: 1000 * 60 * 60, // Cache de 1 heure&#10;    retry: 2,&#10;  });&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/api.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/api.ts" />
              <option name="originalContent" value="/**&#10; * Fonctions pour interagir avec notre API Next.js (base MySQL)&#10; */&#10;&#10;import axios from 'axios';&#10;import type { ApiResponse, SearchParams } from './types';&#10;&#10;/**&#10; * Récupère les restaurants depuis notre API interne (base MySQL)&#10; */&#10;export async function fetchRestaurants(params: SearchParams): Promise&lt;ApiResponse&gt; {&#10;  try {&#10;    const queryParams = new URLSearchParams();&#10;    &#10;    if (params.searchTerm) queryParams.append('search', params.searchTerm);&#10;    if (params.type) queryParams.append('type', params.type);&#10;    if (params.region) queryParams.append('region', params.region);&#10;    if (params.department) queryParams.append('department', params.department);&#10;    if (params.limit) queryParams.append('limit', params.limit.toString());&#10;    if (params.offset) queryParams.append('offset', params.offset.toString());&#10;    if (params.sortBy) queryParams.append('sortBy', params.sortBy);&#10;    if (params.userLat) queryParams.append('userLat', params.userLat.toString());&#10;    if (params.userLon) queryParams.append('userLon', params.userLon.toString());&#10;    &#10;    const url = `/api/restaurants?${queryParams.toString()}`;&#10;    &#10;    const response = await axios.get(url, {&#10;      headers: {&#10;        'Accept': 'application/json',&#10;      },&#10;      timeout: 10000,&#10;    });&#10;    &#10;    return {&#10;      total_count: response.data.total_count || 0,&#10;      results: response.data.results || [],&#10;    };&#10;  } catch (error) {&#10;    if (axios.isAxiosError(error)) {&#10;      if (error.response) {&#10;        throw new Error(`Erreur API (${error.response.status}): ${error.response.statusText}`);&#10;      } else if (error.request) {&#10;        throw new Error('Impossible de contacter l\'API. Vérifiez votre connexion internet.');&#10;      }&#10;    }&#10;    &#10;    throw new Error('Une erreur inattendue s\'est produite lors de la recherche.');&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les régions disponibles depuis notre API interne&#10; */&#10;export async function fetchRegions(): Promise&lt;string[]&gt; {&#10;  try {&#10;    const response = await axios.get('/api/regions');&#10;    return response.data.regions || [];&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des régions:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les départements disponibles pour une région&#10; */&#10;export async function fetchDepartments(region?: string): Promise&lt;string[]&gt; {&#10;  try {&#10;    const queryParams = new URLSearchParams();&#10;    if (region) queryParams.append('region', region);&#10;&#10;    const response = await axios.get(`/api/restaurants?${queryParams.toString()}`);&#10;&#10;    // Extraction des départements uniques&#10;    const departments = new Set&lt;string&gt;();&#10;    response.data.results.forEach((restaurant: { department?: string }) =&gt; {&#10;      if (restaurant.department) {&#10;        departments.add(restaurant.department);&#10;      }&#10;    });&#10;&#10;    return Array.from(departments).sort();&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des départements:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="/**&#10; * Fonctions pour interagir avec notre API Next.js (base MySQL)&#10; */&#10;&#10;import axios from 'axios';&#10;import type { ApiResponse, SearchParams } from './types';&#10;&#10;/**&#10; * Récupère les restaurants depuis notre API interne (base MySQL)&#10; */&#10;export async function fetchRestaurants(params: SearchParams): Promise&lt;ApiResponse&gt; {&#10;  try {&#10;    const queryParams = new URLSearchParams();&#10;    &#10;    if (params.searchTerm) queryParams.append('search', params.searchTerm);&#10;    if (params.type) queryParams.append('type', params.type);&#10;    if (params.location) queryParams.append('location', params.location);&#10;    if (params.arrondissement) queryParams.append('arrondissement', params.arrondissement);&#10;    if (params.limit) queryParams.append('limit', params.limit.toString());&#10;    if (params.offset) queryParams.append('offset', params.offset.toString());&#10;    if (params.sortBy) queryParams.append('sortBy', params.sortBy);&#10;    if (params.userLat) queryParams.append('userLat', params.userLat.toString());&#10;    if (params.userLon) queryParams.append('userLon', params.userLon.toString());&#10;    &#10;    const url = `/api/restaurants?${queryParams.toString()}`;&#10;    &#10;    const response = await axios.get(url, {&#10;      headers: {&#10;        'Accept': 'application/json',&#10;      },&#10;      timeout: 10000,&#10;    });&#10;    &#10;    return {&#10;      total_count: response.data.total_count || 0,&#10;      results: response.data.results || [],&#10;    };&#10;  } catch (error) {&#10;    if (axios.isAxiosError(error)) {&#10;      if (error.response) {&#10;        throw new Error(`Erreur API (${error.response.status}): ${error.response.statusText}`);&#10;      } else if (error.request) {&#10;        throw new Error('Impossible de contacter l\'API. Vérifiez votre connexion internet.');&#10;      }&#10;    }&#10;    &#10;    throw new Error('Une erreur inattendue s\'est produite lors de la recherche.');&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les régions disponibles depuis notre API interne&#10; */&#10;export async function fetchRegions(): Promise&lt;string[]&gt; {&#10;  try {&#10;    const response = await axios.get('/api/regions');&#10;    return response.data.regions || [];&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des régions:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les localisations disponibles (villes + départements fusionnés) depuis notre API interne&#10; */&#10;export async function fetchLocations(): Promise&lt;string[]&gt; {&#10;  try {&#10;    const response = await axios.get('/api/locations');&#10;    return response.data.locations || [];&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des localisations:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les arrondissements disponibles depuis notre API interne&#10; */&#10;export async function fetchArrondissements(): Promise&lt;string[]&gt; {&#10;  try {&#10;    const response = await axios.get('/api/arrondissements');&#10;    return response.data.arrondissements || [];&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des arrondissements:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les villes disponibles depuis notre API interne&#10; */&#10;export async function fetchCities(): Promise&lt;string[]&gt; {&#10;  try {&#10;    const response = await axios.get('/api/cities');&#10;    return response.data.cities || [];&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des villes:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;/**&#10; * Récupère les départements disponibles depuis notre API interne&#10; */&#10;export async function fetchDepartments(): Promise&lt;string[]&gt; {&#10;  try {&#10;    const response = await axios.get('/api/departments');&#10;    return response.data.departments || [];&#10;  } catch (error) {&#10;    console.error('Erreur lors de la récupération des départements:', error);&#10;    return [];&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/lib/types.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/lib/types.ts" />
              <option name="originalContent" value="/**&#10; * Types TypeScript pour l'application Juice Finder France&#10; * Basés sur l'API OpenDataSoft OSM France Food Service&#10; */&#10;&#10;export interface GeoPoint {&#10;  lon: number;&#10;  lat: number;&#10;}&#10;&#10;export interface Restaurant {&#10;  id: string;&#10;  name: string;&#10;  type: string;&#10;  cuisine?: string;&#10;  phone?: string;&#10;  website?: string;&#10;  email?: string;&#10;  street?: string;&#10;  housenumber?: string;&#10;  postcode?: string;&#10;  city?: string;&#10;  region?: string;&#10;  department?: string;&#10;  opening_hours?: string;&#10;  wheelchair?: string;&#10;  delivery?: string;&#10;  takeaway?: string;&#10;  outdoor_seating?: string;&#10;  meta_geo_point?: GeoPoint;&#10;  osm_id?: string;&#10;  osm_type?: string;&#10;}&#10;&#10;export interface ApiResponse {&#10;  total_count: number;&#10;  results: Restaurant[];&#10;}&#10;&#10;export interface SearchParams {&#10;  searchTerm?: string;&#10;  type?: string;&#10;  region?: string;&#10;  department?: string;&#10;  limit?: number;&#10;  offset?: number;&#10;  sortBy?: string;&#10;  userLat?: number;&#10;  userLon?: number;&#10;}&#10;&#10;export type RestaurantType = 'restaurant' | 'bar' | 'cafe' | 'fast_food' | 'pub' | '';&#10;&#10;export type SortBy = 'distance' | 'name' | 'none';&#10;&#10;export interface FilterState {&#10;  type: RestaurantType;&#10;  region: string;&#10;  department: string;&#10;  limit?: number; // Limite du nombre de résultats à récupérer (ex: 100/250/500/1000/2500/5000)&#10;  sortBy?: SortBy; // Tri par distance ou nom&#10;}&#10;&#10;export interface Marker {&#10;  id: string;&#10;  coordinates: [number, number];&#10;  restaurant: Restaurant;&#10;}&#10;" />
              <option name="updatedContent" value="/**&#10; * Types TypeScript pour l'application Juice Finder France&#10; * Basés sur l'API OpenDataSoft OSM France Food Service&#10; */&#10;&#10;export interface GeoPoint {&#10;  lon: number;&#10;  lat: number;&#10;}&#10;&#10;export interface Restaurant {&#10;  id: string;&#10;  name: string;&#10;  type: string;&#10;  cuisine?: string;&#10;  phone?: string;&#10;  website?: string;&#10;  email?: string;&#10;  street?: string;&#10;  housenumber?: string;&#10;  postcode?: string;&#10;  city?: string;&#10;  region?: string;&#10;  department?: string;&#10;  opening_hours?: string;&#10;  wheelchair?: string;&#10;  delivery?: string;&#10;  takeaway?: string;&#10;  outdoor_seating?: string;&#10;  meta_geo_point?: GeoPoint;&#10;  osm_id?: string;&#10;  osm_type?: string;&#10;}&#10;&#10;export interface ApiResponse {&#10;  total_count: number;&#10;  results: Restaurant[];&#10;}&#10;&#10;export interface SearchParams {&#10;  searchTerm?: string;&#10;  type?: string;&#10;  location?: string; // Ville ou département&#10;  arrondissement?: string;&#10;  limit?: number;&#10;  offset?: number;&#10;  sortBy?: string;&#10;  userLat?: number;&#10;  userLon?: number;&#10;}&#10;&#10;export type RestaurantType = 'restaurant' | 'bar' | 'cafe' | 'fast_food' | 'pub' | '';&#10;&#10;export type SortBy = 'distance' | 'name' | 'none';&#10;&#10;export interface FilterState {&#10;  type: RestaurantType;&#10;  location?: string; // Ville ou département&#10;  arrondissement?: string;&#10;  limit?: number; // Limite du nombre de résultats à récupérer (ex: 100/250/500/1000/2500/5000)&#10;  sortBy?: SortBy; // Tri par distance ou nom&#10;}&#10;&#10;export interface Marker {&#10;  id: string;&#10;  coordinates: [number, number];&#10;  restaurant: Restaurant;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>